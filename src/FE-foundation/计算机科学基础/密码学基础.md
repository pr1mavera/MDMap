---
title: 密码学基础
date: 2019-08-13
---

+ 密码学的处理对象是**数字**和**字符串**
    + 早期密码学加密手段主要是类似于**移位替换**的方式
    + 现代密码学是建立在数论基础上的

## 散列算法(hash、MD5)

是一种数据一旦转换为其他形式将永远无法恢复的加密技术(混淆技术、不可逆运算，基本上不算是加密算法)
+ 主要应用场景：*用户登录功能*
    1. 用户输入的密码后通过信道(http)发送到服务端
    2. 发送之前在客户端通过**散列算法**进行加密再传输(实际上到了服务器这头，服务器存贮的也是加密后面的密码)
    3. 如果通信的过程中被截获，得到的也只能是加密后的密码，一定程度上保证了安全性(散列算法也是可以通过某种方式暴力破解的)

## 加密算法
+ `对称加密` (AES、DES、3DES)(**加密过程与解密过程使用同一套算法**)
    + 数据传输双方在不同地方，同时持有 *加密算法* 及 *解密口令*，依旧很不安全
+ `非对称加密` (RSA)(**加密与解密分开，公钥用来加密，私钥用来解密**)
    + A ----- 传输 -----> B ，A 根据 B 的公钥进行加密，B 收到后用 B 的私钥解密
    + A <----- 传输 ----- B ，B 根据 A 的公钥进行加密，A 收到后用 A 的私钥解密

::: tip
在https中同时用到了 *对称加密* 和 *非对称加密* 两种算法：
1. https握手过程中传递 *主密钥* 时使用 **非对称加密**，客户端根据密钥交换算法生成 *预主密钥*， *预主密钥* 通过服务器公钥加密后传输给服务器端，服务器端使用私钥解密得到 *预主密钥*
2. https握手结束后的通讯，使用的时候 **对称加密** ，因为 **非对称加密** 的性能是非常低的，原因在于寻找大素数、大数计算、数据分割需要耗费很多的CPU周期
:::

以下便是 https 中比较有名的密钥交换算法：

## 密钥交换算法

+ Diffie-Hellman 算法是一种著名的密钥协商算法（**在两端点之间进行公开的密钥交换，同时如果他人拿到该密钥也无法使用**），利用的是 [离散对数数学难题](https://en.wikipedia.org/wiki/Discrete_logarithm)，即 `A = g ^ a (mod p)` ，在已知的 A, g, p 条件下，很难求得 a
    1. Alice 与 Bob 确定两个大素数 n 和 g (位数现在在4K左右) ，这两个数不用保密
    2. Alice 选择另一个大随机数 x ，并计算 A 如下：A = (g ^ x) mod n，将 A 发给 Bob
    3. Bob 选择另一个大随机数 y ，并计算 B 如下：B = (g ^ y) mod n，将 B 发给 Alice
    4. Alice 用收到的 B 计算密钥 K1 = (B ^ x) mod n
    5. Bob 用收到的 A 计算密钥 K2 = (A ^ y) mod n
    6. K1 = K2，因此 Alice 和 Bob 可以用其进行加解密

::: tip
1. 加密解密过程
    + 加密 ：明文 + 密钥 + 算法 -> 密文
    + 解密 ：密文 + 密钥 + 算法 -> 明文
2. **对称加密** 与 **非对称加密** 区别，在上述过程中的密钥：
    + 对称加密 为一样的 `key`
    + 非对称加密 加密为 `公钥` ，解密为 `私钥`
3. 素数: 一个数只能被1和他自己整除的数
4. mod: 求模运算，得到一个数除以另一个数的余数
5. 证明以上 K1 = K2 :  
    已知：求模运算满足公式 `(((a ^ b) mod p) ^ c) mod p = ((a ^ b) ^ c) mod p) mod p`  
    K1  
    = (B ^ x) mod n  
    = (((g ^ y) mod n) ^ x) mod n  
    = ((g ^ y) ^ x) mod n  
    = (g ^ (y * x)) mod n  
    = (g ^ (x * y)) mod n  
    = ((g ^ x) ^ y) mod n  
    = (((g ^ x) mod n) ^ y) mod n  
    = (A ^ y) mod n  
    = K2
:::

## 证书签发机构 (CA)
CA (certification authority) 第三方受信用部门，用不对称算法对数据加密密钥的进行安全交换，再利用数据加密密钥完成数据的安全交换

+ 证书创建：
    1. 服务器 example.com 将从CA（签发机构，例如 **Digicert** ）请求 **TLS证书**
    2. **Digicert** 为 example.com 创建证书，包含某些必要信息，*服务器名称* 、 *服务器公钥* 等，暂且叫 `Data`
    3. **Digicert** 为必要信息 `Data` 生成签名串：  
    **`Data`** <span style="font-size:10px;border-bottom:1px solid #67cc86;">指定散列算法 > </span> **`Data` 的哈希值** <span style="font-size:10px;border-bottom:1px solid #67cc86;">自己的私钥加密 > </span> **签名串 `sign`**
    4. **Digicert** 将 `Data` 、 `sign` 以及 *散列算法* 合并成最终的 **TLS证书** 发送给服务器
+ 证书使用：
    1. **浏览器** 访问网站，收到服务器的相关证书，拿到 `Data` 、 `sign` 以及 *散列算法*
    2.  `Data` <span style="font-size:10px;border-bottom:1px solid #67cc86;">指定散列算法 > </span> **哈希值**
    3.  `sign` <span style="font-size:10px;border-bottom:1px solid #67cc86;">签发机构的公钥（浏览器或系统自带）解密 > </span> **哈希值**
    4. 若两个 **哈希值** 相等，则说明证书有效
+ 根证书 & 中间证书
    + 签发机构维护的所有证书签名都是用一套公钥私钥进行加解密，因此对这份私钥的安全性要求很高。因此为了解决这个问题，引入了中间签发机构的概念
    + 中间签发机构从根机构那里取得签发权限证书（intermediate CA），注册成为代理机构，签发证书
    + 浏览器访问时，服务器需共享出两个证书：第三方签发的证书、根机构给第三方签发的 intermediate CA
